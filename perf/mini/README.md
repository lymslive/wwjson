# wwjson 汇编分析最简示例

本目录包含最简示例，用于研究编译器对 wwjson 整数序列化和 JSON 构建代码的优化效果。

## 示例文件

| 文件 | 描述 | 关注点 |
|------|------|--------|
| `itoa_u16.cpp` | uint16_t 序列化 | 递归模板展开，除法/取模优化 |
| `itoa_u32.cpp` | uint32_t 序列化 | 同上，处理更大数值 |
| `builder.cpp` | 最简 JSON 构建 | 函数内联，直接缓冲区写入 |
| `dyn_json.cpp` | 动态 JSON 构建 | 运行时变量对优化的影响 |

## 快速开始

```bash
# 构建所有示例
make

# 生成汇编文件
make asm

# 运行示例
make run

# 清理生成的文件
make clean
```

## 汇编分析要点

运行 `make asm` 后会生成以下文件：

- `*_linux.exe` - 编译后的可执行文件
- `*.s` - 带源码对照的反汇编文件

### 整数序列化 (itoa_u16/itoa_u32)

**关键观察**：

1. **字面量（编译期常量）**：
   - ✅ `UnsignedWriter` 模板递归完全展开
   - ✅ 除法/取模操作优化为查表
   - ✅ 无 `div` 指令，5 次查表操作

2. **运行时变量**：
   - ⚠️ 出现 `div` 指令（除法开销）
   - ⚠️ 编译器生成复杂的分支逻辑处理不同位数
   - ⚠️ 查表操作需要运行时计算索引
   - ⚠️ **无函数调用开销**：模板方法被内联，但编译器生成了一套完整的运行时整数转换算法（除法 + 分支）

### JSON 构建 (builder)

**关键观察**：

1. **静态 JSON（字面量）**：
   - ✅ 整个 JSON 在编译期构建
   - ✅ 所有函数完全内联，无调用开销
   - ✅ 直接在栈上写入最终字符串

2. **动态 JSON（dyn_json）**：
   - ⚠️ 整数部分需要运行时转换
   - ⚠️ 出现 `memcpy` 调用复制动态内容
   - ⚠️ 函数未完全内联

### 性能对比

| 场景 | 指令数 | 除法指令 | 函数调用 | 优化程度 |
|------|--------|----------|----------|----------|
| itoa_u32 字面量 | ~15 | 0 | 0 | 完全优化 |
| itoa_u32 运行时 | ~100+ | 2+ | 0 | 部分优化 |
| builder 静态 | ~30 | 0 | 0 | 完全优化 |
| build_json 动态 | ~50+ | 0 | 1 memcpy | 部分优化 |

### 关键结论

1. **编译期常量 vs 运行时变量**
   - 字面量整数：编译期完全优化，性能 ~3-5 周期
   - 运行时整数：编译器生成运行时算法（除法 + 分支），性能 ~50-100+ 周期

2. **无调用开销 vs 复杂分支**
   - 字面量：模板递归完全展开，5次查表，无分支
   - 运行时：模板被内联但生成完整运行时算法（除法 + 多层分支判断位数）

3. **设计启示**
   - 如果整数已知，应使用模板参数或 constexpr
   - wwjson 的查表优化仅对编译期常量有效
   - 动态内容的 JSON 构建无法避免运行时开销

## CI 集成

参见 `.github/workflows/ci-mini.yml` 中的自动化汇编分析配置。

## 注意事项

- 可执行文件后缀 `*_linux.exe` 用于区分 Windows 原生 `.exe`
- `*.exe` 和 `*.s` 文件已被 gitignore 忽略
