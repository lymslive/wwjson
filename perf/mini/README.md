# wwjson 汇编分析最简示例

本目录包含最简示例，用于研究编译器对 wwjson 整数序列化和 JSON 构建代码的优化效果。

## 示例文件

| 文件 | 描述 | 关注点 |
|------|------|--------|
| `itoa_u8.cpp` | uint8_t 序列化 | 最小类型，单字节处理 |
| `itoa_u16.cpp` | uint16_t 序列化 | 递归模板展开，除法/取模优化 |
| `itoa_u32.cpp` | uint32_t 序列化 | 同上，处理更大数值 |
| `itoa_u64.cpp` | uint64_t 序列化 | 最大类型，处理大数值 |
| `builder.cpp` | 最简 JSON 构建 | 函数内联，直接缓冲区写入 |
| `dyn_json.cpp` | 动态 JSON 构建 | 运行时变量对优化的影响 |

## 快速开始

```bash
# 构建所有示例
make

# 生成汇编文件
make asm

# 运行示例
make run

# 清理生成的文件
make clean
```

## 汇编分析要点

运行 `make asm` 后会生成以下文件：

- `*_linux.exe` - 编译后的可执行文件
- `*.s` - 带源码对照的反汇编文件

### 整数序列化 (itoa_u8/itoa_u16/itoa_u32/itoa_u64)

本分析基于当前实现版本，对比编译期常量与运行时变量的优化差异。

#### 核心发现

**关键结论**：通过函数参数传递后，编译期常量和运行时变量在编译器优化后生成的汇编代码**几乎完全相同**。

#### 详细分析

##### 1. itoa_u8 (uint8_t)

**测试常量**：122

**汇编特点**（itoa_const 与 itoa_var 完全一致）：
- ✅ 使用 `cmp` 指令进行范围判断（0-9, 10-99, 100-199, 200-255）
- ✅ 使用查表法（kDigitPairs）生成数字对
- ✅ **无 `div` 指令**，编译器完全优化了除法操作
- ✅ 代码大小：约 90 指令（const 和 var 版本相同）

**优化说明**：uint8_t 数值范围小，编译器通过分支判断 + 查表实现，无需除法指令。

##### 2. itoa_u16 (uint16_t)

**测试常量**：12233

**汇编特点**（itoa_const 与 itoa_var 几乎完全一致）：
- ✅ 使用 `imul` 指令配合魔法常数（magic constant 0x147b）实现除法优化
- ✅ 使用查表法（kDigitPairs）生成数字对
- ✅ **无 `div` 指令**，除法被优化为乘法 + 位移
- ✅ 使用 `sar`（算术右移）指令实现高效除法
- ✅ 代码大小：约 100 指令（const 和 var 版本相同）

**关键指令序列**（除法优化）：
```asm
imul $0x147b,%eax,%eax   ; 乘法
sar $0x13,%eax           ; 右移（相当于除以 8192）
imul $0x64,%eax,%edx     ; 乘以 100（获取百位）
sub %edx,%edi            ; 减去百位部分
```

##### 3. itoa_u32 (uint32_t)

**测试常量**：1122334455

**汇编特点**（itoa_const 与 itoa_var 几乎完全一致）：
- ✅ 使用魔法常数（0x68db8bb, 0x147b, 0x2710）实现多层除法优化
- ✅ 使用查表法（kDigitPairs）生成数字对
- ✅ **无 `div` 指令**，所有除法均被优化
- ✅ 处理 5 位数时使用 64 位魔法常数（0xd1b71759）
- ✅ 代码大小：约 180 指令（const 和 var 版本相同）

**优化策略**：编译器根据数值大小（<10000, <1000000, <100000000, 其他）选择不同的优化路径。

##### 4. itoa_u64 (uint64_t)

**测试常量**：112233445566778899

**汇编特点**（const 和 var 版本）：
- ⚠️ 两者都调用 `IntegerWriter<UnsafeBuffer>::WriteUnsigned` 函数
- ✅ **无 `div` 指令**，使用魔法常数（0xabcc77118461cefd, 0xde0b6b3a763ffff 等）
- ✅ 使用 128 位乘法（`mul %r9`）处理大数除法
- ✅ 使用查表法（kDigitPairs）生成数字对
- ✅ 函数完全内联，无调用开销
- ✅ 代码大小：WriteUnsigned 函数约 600 指令

**关键优化**：对于大整数除法，编译器使用更复杂的魔法常数和 128 位乘法。

#### 性能对比

| 类型 | 场景 | 指令数 | 除法指令 (div) | 函数调用 | 优化程度 |
|------|------|--------|----------------|----------|----------|
| uint8_t | const/var | ~90 | 0 | 0 | 完全优化 |
| uint16_t | const/var | ~100 | 0 | 0 | 完全优化 |
| uint32_t | const/var | ~180 | 0 | 0 | 完全优化 |
| uint64_t | const/var | ~600* | 0 | 0 | 完全优化 |

*注：u64 包含 WriteUnsigned 函数的完整实现

#### 关键技术总结

##### 魔法常数优化

编译器使用**魔法常数乘法**替代除法指令，公式：
```
quotient = (dividend * magic) >> shift
```

示例（uint16_t）：
- 魔法常数：0x147b = 5243
- 右移位数：19 (0x13)
- 实际除法：value / 8192

##### 查表优化

使用 `kDigitPairs` 数组预计算 0-99 的两位数字表示：
- 单次查表生成两位数字
- 避免重复的除法/取模操作
- 内存访问延迟低于除法指令

##### 范围判断优化

使用 `cmp` + 条件跳转实现多路分支：
- 根据数值大小选择优化路径
- 避免不必要的计算
- 现代CPU的分支预测器能有效优化

#### 重要结论

1. **编译期常量 vs 运行时变量**
   - 在通过函数参数传递后，两者生成的汇编代码**几乎完全相同**
   - 编译器无法在函数调用时推断参数是否为常量
   - 优化主要由编译器的通用优化器实现，而非常量传播

2. **无除法指令的设计**
   - 所有类型（u8/u16/u32/u64）均无 `div` 指令
   - 除法被完全优化为乘法 + 位移 + 查表
   - 这是编译器优化器 + wwjson 代码设计共同作用的结果

3. **模板递归展开的影响**
   - 模板递归被编译器内联展开
   - 生成的代码不包含递归调用
   - 编译器能进一步优化展开后的代码

4. **设计启示**
   - wwjson 的查表优化对**所有情况**有效（const 和 var）
   - 函数参数传递后，编译期常量优势消失
   - 如需保持编译期优化，应使用模板参数而非函数参数
   - 当前实现已达到编译器优化的极限

### JSON 构建 (builder)

**关键观察**：

1. **静态 JSON（字面量）**：
   - ✅ 整个 JSON 在编译期构建
   - ✅ 所有函数完全内联，无调用开销
   - ✅ 直接在栈上写入最终字符串

2. **动态 JSON（dyn_json）**：
   - ⚠️ 整数部分需要运行时转换
   - ⚠️ 出现 `memcpy` 调用复制动态内容
   - ⚠️ 函数未完全内联

### 性能对比

| 场景 | 指令数 | 除法指令 | 函数调用 | 优化程度 |
|------|--------|----------|----------|----------|
| itoa_u8 const/var | ~90 | 0 | 0 | 完全优化 |
| itoa_u16 const/var | ~100 | 0 | 0 | 完全优化 |
| itoa_u32 const/var | ~180 | 0 | 0 | 完全优化 |
| itoa_u64 const/var | ~600 | 0 | 0 | 完全优化 |
| builder 静态 | ~30 | 0 | 0 | 完全优化 |
| dyn_json 动态 | ~50+ | 0 | 1 memcpy | 部分优化 |

## CI 集成

参见 `.github/workflows/ci-mini.yml` 中的自动化汇编分析配置。

## 注意事项

- 可执行文件后缀 `*_linux.exe` 用于区分 Windows 原生 `.exe`
- `*.exe` 和 `*.s` 文件已被 gitignore 忽略
